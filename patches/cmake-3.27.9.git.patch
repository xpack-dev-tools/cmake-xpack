From 6fe677ca51073d5b233aef9a854793351a192f65 Mon Sep 17 00:00:00 2001
From: Liviu Ionescu <ilg@livius.net>
Date: Wed, 14 Feb 2024 10:24:40 +0200
Subject: [PATCH] add support for .cmd shims

---
 Source/kwsys/ProcessWin32.c | 113 ++++++++++++++++++++++++++++++++++++
 1 file changed, 113 insertions(+)

diff --git a/Source/kwsys/ProcessWin32.c b/Source/kwsys/ProcessWin32.c
index 0b43b4a2af..027df76d78 100644
--- a/Source/kwsys/ProcessWin32.c
+++ b/Source/kwsys/ProcessWin32.c
@@ -31,6 +31,7 @@ a UNIX-style select system call.
 #include <io.h>     /* _unlink */
 #include <stdio.h>  /* snprintf */
 #include <string.h> /* strlen, strdup */
+#include <stdbool.h>
 
 #ifndef _MAX_FNAME
 #  define _MAX_FNAME 4096
@@ -1705,6 +1706,116 @@ DWORD kwsysProcessCreate(kwsysProcess* cp, int index,
     creationFlags |= CREATE_NEW_PROCESS_GROUP;
   }
 
+#if 1
+
+  /* This patch adds support for running .cmd shims
+     via a cmd.exe sub-shell. */
+  wchar_t* wFrom = cp->Commands[index];
+  size_t fromLength = wcslen(wFrom);
+
+  // fwprintf(stderr, L"[1: [%s],%d]\n", wFrom, fromLength);
+
+  wchar_t* wp = wFrom;
+
+  /* Skip initial spaces. */
+  while (*wp == L' ' || *wp == L'\t') {
+    ++wp;
+  }
+
+  if (*wp == L'"') {
+    while (*++wp != L'"')
+      ;
+    /* Stop on the ending quote. */
+  } else {
+    while (*wp != L' ' && *wp != L'\t') {
+      ++wp;
+    }
+    /* Stop on the first space. */
+  }
+
+  wchar_t* wCmd;
+
+  wchar_t wDotCmd[] = L".cmd";
+
+  // wchar_t xx[5] = L"";
+  // wcsncat(xx, wp - wcslen(wDotCmd), wcslen(wDotCmd));
+  // fwprintf(stderr, L"[x: %s]\n", xx);
+
+  if (wcsncmp(wp - wcslen(wDotCmd), wDotCmd, wcslen(wDotCmd)) != 0) {
+    /* If not an explicit .cmd, execute it directly. */
+    wCmd = malloc((fromLength + 1) * sizeof(wchar_t));
+    wcscpy(wCmd, wFrom);
+  } else {
+    /* Explicit .cmd, run it via a cmd.exe sub-shell. */
+
+    wchar_t wCmdExe[] = L"cmd.exe /s /c \" ";
+    wchar_t wCmdEnd[] = L" \"";
+
+    /* cmd.exe requires escaping several characters.
+     * To prevent automatic escaping, surround the string with quotes. */
+    wchar_t escapedChars[] = L"&\\<>^|";
+
+    bool inQuotedString = false;
+
+    /* Count the number of characters that need to be escaped. */
+    size_t escapedCount = 0;
+    for (size_t i = 0; i < fromLength; ++i) {
+      wchar_t wChr = wFrom[i];
+      if (wChr == L'"') {
+        inQuotedString = !inQuotedString;
+      }
+      if (!inQuotedString && wcsrchr(escapedChars, wChr) != NULL) {
+        ++escapedCount;
+      }
+    }
+
+    // fwprintf(stderr, L"[2: %d]\n", escapedCount);
+
+    wCmd = malloc(
+      (wcslen(wCmdExe) + fromLength + escapedCount + wcslen(wCmdEnd) + 1)
+      * sizeof(wchar_t)
+    );
+
+    wcscpy(wCmd, wCmdExe);
+
+    if (escapedCount > 0) {
+      inQuotedString = false;
+      wchar_t* wTo = wCmd + wcslen(wCmdExe);
+      for (size_t i = 0; i < fromLength; ++i) {
+        wchar_t wChr = wFrom[i];
+        if (wChr == L'"') {
+          inQuotedString = !inQuotedString;
+        }
+        if (!inQuotedString && wcsrchr(escapedChars, wChr) != NULL) {
+          *wTo++ = L'^';
+        }
+        *wTo++ = wChr;
+      }
+      *wTo++ = L'\0';
+    } else {
+      wcscat(wCmd, wFrom);
+    }
+    wcscat(wCmd, wCmdEnd);
+  }
+
+  // fwprintf(stderr, L"[3: [%s],%d]\n", wCmd, wcslen(wCmd));
+
+  /* Create inherited copies of the handles.  */
+  (error = kwsysProcessCreateChildHandle(&si->StartupInfo.hStdInput,
+                                         si->hStdInput, 1)) ||
+    (error = kwsysProcessCreateChildHandle(&si->StartupInfo.hStdOutput,
+                                           si->hStdOutput, 0)) ||
+    (error = kwsysProcessCreateChildHandle(&si->StartupInfo.hStdError,
+                                           si->hStdError, 0)) ||
+    /* Create the process.  */
+    (!CreateProcessW(0, wCmd, 0, 0, TRUE, creationFlags, 0, 0,
+                     &si->StartupInfo, &cp->ProcessInformation[index]) &&
+     (error = GetLastError()));
+
+  free(wCmd);
+
+#else
+
   /* Create inherited copies of the handles.  */
   (error = kwsysProcessCreateChildHandle(&si->StartupInfo.hStdInput,
                                          si->hStdInput, 1)) ||
@@ -1717,6 +1828,8 @@ DWORD kwsysProcessCreate(kwsysProcess* cp, int index,
                      &si->StartupInfo, &cp->ProcessInformation[index]) &&
      (error = GetLastError()));
 
+#endif
+
   /* Close the inherited copies of the handles. */
   if (si->StartupInfo.hStdInput != si->hStdInput) {
     kwsysProcessCleanupHandle(&si->StartupInfo.hStdInput);
-- 
2.39.3 (Apple Git-145)

